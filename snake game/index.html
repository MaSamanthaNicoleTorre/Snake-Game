<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Snake Game</title>

<link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet" />

<style>
  body {
    margin: 0;
    background: radial-gradient(circle at center, #1a1a2e, #0f0f1a);
    font-family: 'Orbitron', sans-serif;
    color: #f0d046;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    height: 100vh;
    padding: 20px;
    user-select: none;
  }
  h1 {
    font-size: 3rem;
    margin-bottom: 10px;
    text-shadow: 0 0 10px #f0d046, 0 0 20px #f0d046;
  }

  /* ------------- BET PANEL ------------- */
  .bet-panel{
    display:flex;
    gap:.75rem;
    align-items:center;
    background:#222a33;
    padding:.6rem 1rem;
    border-radius:.75rem;
    box-shadow:0 0 12px #f0d046;
    margin-bottom:1.25rem;
  }
  .bet-panel input{
    width:5rem;
    padding:.3rem .4rem;
    border:none;
    border-radius:.3rem;
    font-family:inherit;
    background:#111820;
    color:#f0d046;
  }
  #start-btn{
    padding:.4rem 1rem;
    border:none;
    border-radius:.4rem;
    cursor:pointer;
    background:#00ff85;
    color:#122228;
    font-weight:700;
    box-shadow:0 0 8px #00ff85;
    transition:transform .1s;
  }
  #start-btn:active{ transform:scale(.96); }
  #start-btn[disabled]{ opacity:.5; cursor:not-allowed; }

  /* ------------- SCOREBOARD / GAME ------------- */
  #scoreboard{
    font-size:1.5rem;
    margin-bottom:20px;
    display:flex;
    gap:40px;
  }
  #scoreboard div{
    background:#222a33;
    padding:10px 20px;
    border-radius:10px;
    box-shadow:0 0 10px #f0d046;
    min-width:150px;
    text-align:center;
  }
  canvas{
    background:#122228;
    border-radius:15px;
    box-shadow:0 0 25px #f6ff00, inset 0 0 20px #004022;
  }
  #instructions{
    margin-top:20px;
    max-width:400px;
    font-size:.9rem;
    color:#aaa;
    text-align:center;
  }

  /* ------------- RESULT MESSAGE ------------- */
  #message{
    position:fixed;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    background:#222a33;
    padding:1.5rem 2.5rem;
    border-radius:.75rem;
    font-size:1.5rem;
    color:#f0d046;
    box-shadow:0 0 15px #00ff85;
    text-align:center;
    z-index:1000;
    line-height:1.4;
  }
  .hidden{ display:none; }
</style>
</head>
<body>
  <h1>Snake Game</h1>

  <!-- ------------- BETTING UI ------------- -->
  <div id="wallet" class="bet-panel">
    <span>Balance: â‚±<span id="balance">0</span></span>

    <label>
      Bet&nbsp;â‚±<input type="number" id="bet-input" min="1" step="1" value="10" />
    </label>

    <button id="start-btn">Start Game</button>
  </div>

  <!-- ------------- SCOREBOARD ------------- -->
  <div id="scoreboard">
    <div>Current Score: <span id="score">0</span></div>
    <div>Total Points: <span id="totalPoints">0</span></div>
  </div>

  <!-- ------------- GAME CANVAS ------------- -->
  <canvas id="gameCanvas" width="400" height="400"></canvas>

  <div id="instructions">
    Use arrow keys or WASD to control the snake.<br/>
    Eat the green squares to grow and score points.<br/>
    Reach 100+ to double your stake!<br/>
    Points accumulate across games, even if you lose.
  </div>

  <!-- ------------- RESULT MESSAGE OVERLAY ------------- -->
  <div id="message" class="hidden"></div>

<!-- ------------- SCRIPTS ------------- -->
<script type="module">
/* ==== AUDIO ====*/
const sounds = {
  start: new Audio('./audio/start.mp3'),
  eat  : new Audio('./audio/eat.wav'),
  end  : new Audio('./audio/end.wav')
};
// optional volume tweaking
Object.values(sounds).forEach(a => (a.volume = 0.6));

/* ===== WALLET / BETTING LAYER ===== */
const STARTING_BALANCE      = 100;  // seed on first visit
const PAYOUT_MULTIPLIER     = 2;    // 2Ã— stake for win
const WIN_SCORE_THRESHOLD   = 100;  // pay out when â‰¥ this score

const balanceEl  = document.getElementById('balance');
const betInput   = document.getElementById('bet-input');
const startBtn   = document.getElementById('start-btn');
const messageEl  = document.getElementById('message');

// helpers
const getBalance = () => +localStorage.getItem('snake_balance') || STARTING_BALANCE;
const setBalance = v  => localStorage.setItem('snake_balance', v);

// initialise wallet UI
if (!localStorage.getItem('snake_balance')) setBalance(STARTING_BALANCE);
updateBalanceUI();

// --------- MESSAGE UTIL ---------
function showMessage(html, autoHide = false, ms = 3000){
  messageEl.innerHTML = html;
  messageEl.classList.remove('hidden');
  if(autoHide){
    setTimeout(()=>messageEl.classList.add('hidden'), ms);
  }
}

function hideMessage(){
  messageEl.classList.add('hidden');
}

startBtn.addEventListener('click', async () => {
  hideMessage();
  const stake = +betInput.value;

  if (!Number.isFinite(stake) || stake <= 0) {
    showMessage('Enter a valid stake!', true);
    return;
  }
  if (stake > getBalance()) {
    showMessage('Not enough funds.', true);
    return;
  }

  /* Start-game sound */
  sounds.start.currentTime = 0;
  sounds.start.play();

  // lock UI + deduct stake
  betInput.disabled = true;
  startBtn.disabled = true;
  setBalance(getBalance() - stake);
  updateBalanceUI();

  // run the snake game, wait for final score
  const score = await snakeGame.start();

  // settle wager
  const win = score >= WIN_SCORE_THRESHOLD;
  const payout = win ? stake * PAYOUT_MULTIPLIER : 0;
  if (payout) setBalance(getBalance() + payout);
  updateBalanceUI();

  const resultHtml = `${win ? 'ðŸŽ‰ <strong>You won!</strong>' : '<strong>You lost.</strong>'}` +
                     `<br>Round score: ${score}` +
                     `<br>${win ? `+â‚±${payout} ðŸŽ‰` : 'Better luck next time!'}`;
  showMessage(resultHtml);

  // unlock UI
  betInput.disabled = false;
  startBtn.disabled = false;
});

function updateBalanceUI () {
  balanceEl.textContent = getBalance().toLocaleString();
}

/* ===== SNAKE GAME (slightly refactored) ===== */
const snakeGame = (() => {

  const canvas   = document.getElementById('gameCanvas');
  const ctx      = canvas.getContext('2d');

  const scale    = 20;
  const rows     = canvas.height / scale;
  const cols     = canvas.width  / scale;

  let snake, direction, food, score, totalPoints;
  let scoreEl     = document.getElementById('score');
  let totalPointsEl = document.getElementById('totalPoints');
  let gameInterval, isGameOver, onDone;

  // expose a promise-based start
  function start () {
    return new Promise(resolve => {
      onDone = resolve;
      init();
    });
  }

  function init () {
    snake = [
      {x: 8 * scale, y: 10 * scale},
      {x: 7 * scale, y: 10 * scale},
      {x: 6 * scale, y: 10 * scale}
    ];
    direction     = {x: 1, y: 0};
    food          = {};
    score         = 0;
    totalPoints   = parseInt(localStorage.getItem('snakeTotalPoints')) || 0;
    totalPointsEl.textContent = totalPoints;
    placeFood();
    updateScore();

    isGameOver    = false;
    if (gameInterval) clearInterval(gameInterval);
    gameInterval  = setInterval(gameLoop, 150);
  }

  function updateScore () {
    scoreEl.textContent = score;
    totalPointsEl.textContent = totalPoints;
  }

  function placeFood () {
    food.x = Math.floor(Math.random() * cols) * scale;
    food.y = Math.floor(Math.random() * rows) * scale;
    for (const segment of snake) {
      if (segment.x === food.x && segment.y === food.y) {
        placeFood(); break;
      }
    }
  }

  function gameLoop () {
    if (isGameOver) return;

    let newHead = {
      x: snake[0].x + direction.x * scale,
      y: snake[0].y + direction.y * scale
    };

    // wall/self collision
    if (
      newHead.x < 0 || newHead.x >= canvas.width ||
      newHead.y < 0 || newHead.y >= canvas.height ||
      snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)
    ) {
      return endGame();
    }

    snake.unshift(newHead);

    // eat food
    if (newHead.x === food.x && newHead.y === food.y) {
      /* Eat sound */
      sounds.eat.currentTime = 0;
      sounds.eat.play();

      score += 10;
      totalPoints += 10;
      localStorage.setItem('snakeTotalPoints', totalPoints);
      updateScore();
      placeFood();
    } else {
      snake.pop();
    }

    draw();
  }

  function draw () {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // food
    ctx.fillStyle   = '#00ff85';
    ctx.shadowColor = '#00ff85';
    ctx.shadowBlur  = 12;
    ctx.fillRect(food.x, food.y, scale, scale);

    // snake
    ctx.shadowColor = 'transparent';
    ctx.fillStyle   = '#f0d046';
    ctx.strokeStyle = '#403b0d';
    ctx.lineWidth   = 2;
    for (const s of snake) {
      ctx.fillRect(s.x, s.y, scale, scale);
      ctx.strokeRect(s.x, s.y, scale, scale);
    }
  }

  function endGame () {
    /* Game-over sound */
    sounds.end.currentTime = 0;
    sounds.end.play();

    isGameOver = true;
    clearInterval(gameInterval);
    // resolve promise with final score
    if (onDone) onDone(score);
  }

  // keyboard
  document.addEventListener('keydown', e => {
    if (isGameOver) return;
    const k = e.key.toLowerCase();
    if ((k === 'arrowleft'||k==='a') && direction.x!==1)  direction = {x:-1,y:0};
    else if((k==='arrowup'||k==='w') && direction.y!==1)  direction = {x:0,y:-1};
    else if((k==='arrowright'||k==='d')&& direction.x!==-1)direction = {x:1,y:0};
    else if((k==='arrowdown'||k==='s') && direction.y!==-1)direction = {x:0,y:1};
  });

  // public API
  return { start };
})();
</script>
</body>
</html>
